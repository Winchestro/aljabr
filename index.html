<!doctype html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
		<meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1.0, user-scalable=yes">
		<title>GLElements Test</title>
  		
		
		<iframe src="src/PolyCore.html"></iframe>
		<style>
			body {
				background : #333;
			}
			canvas {
				width : 100%;
				height : 100%;
				position : fixed;
				top : 0;
				left : 0;
				background : #444;
			}
			iframe {
				display : none;
			}
		</style>
	</head> 
	<body>
		<script id="vsCode" type="GLSL">
			precision lowp float;
			precision highp int;
			attribute vec2 aVertex;
			attribute vec4 aColor;
			attribute float test;
			varying vec4 vColor;
			void main ( void ) {
				float a = test;
				gl_Position = vec4( aVertex , 0, 1 );
				vColor = aColor;
			}
		</script>
		<script id="fsCode" type="GLSL">
			precision lowp float;
			precision highp int;
			varying vec4 vColor;
			void main ( void ) {
				gl_FragColor = vColor;
			}
		</script>
		<script>
			function main (
				canvas, 
				gl, 
				core,
				math 
			) {
				window.gl = gl;
				window.core = core;
				window.math = math;

				const Program = core.Program;
				const VertexShader = core.VertexShader;
				const FragmentShader = core.FragmentShader;
				const StaticArrayBuffer = core.StaticArrayBuffer;
				const StaticElementBuffer = core.StaticElementBuffer;
				const DynamicArrayBuffer = core.DynamicArrayBuffer;
			

				canvas.width = innerWidth;
				canvas.height = innerHeight;
				gl.viewport(0,0,innerWidth,innerHeight);
				document.body.appendChild(canvas);
				
				program = new Program()
				.attachShader( new VertexShader( vsCode.innerText ))
				.attachShader( new FragmentShader( fsCode.innerText ))
				.bindAttribLocation( 0, "aVertex" )
				.bindAttribLocation( 1, "aColor" )
				.link()
				.validate()
				.use();


				vertices = new StaticArrayBuffer( new Float32Array([
					 0,  0,
					-1,  1,
					-1, -1,
					 1, -1,
					 1,  1
				]) )
				.vertexAttribPointer( 0, 2, gl.FLOAT, false, 0, 0)
				.enableVertexAttribArray( 0 )
				;
				
				colors = new DynamicArrayBuffer( new Float32Array(5 * 4) )
				.vertexAttribPointer( 1, 4, gl.FLOAT, false, 0, 0)
				.enableVertexAttribArray( 1 )
				;

				indices = new StaticElementBuffer( new Uint8Array([
					0,1,2,0,3,0,4,0,1
				]) );

				var frame = 0;
				var size = indices.getSize;
				void function draw(){
					frame++;
					requestAnimationFrame(draw);
					colors.bind();
					colors.data.set([
						1,
						1,
						1,
						0,
						(Math.sin(frame*.19)+1)*.5, 
						(Math.cos(-frame*.11)+1)*.5, 
						(Math.cos(frame*.13)+1)*.5, 
						1,
						(Math.cos(frame*.12)+1)*.5, 
						(Math.sin(-frame*.15)+1)*.5, 
						(Math.sin(frame*.1)+1)*.5, 
						1,
						(Math.cos(frame*.12)+1)*.5, 
						(Math.sin(frame*.11)+1)*.5, 
						(Math.cos(-frame*.1)+1)*.5, 
						1,
						(Math.sin(-frame*.1)+1)*.5, 
						(Math.cos(frame*.16)+1)*.5, 
						(Math.sin(frame*.122)+1)*.5, 
						1
					])
					colors.bufferSubData( 0, colors.data );
					
					program.drawElements(gl.TRIANGLE_STRIP, size, gl.UNSIGNED_BYTE, 0);
					//program.drawElements(GL.LINE_STRIP,indices.SIZE / 2,GL.UNSIGNED_SHORT,0);
				}();	
			}
		</script>
	</body>
</html>
<!--canvas id="mainWindow"></canvas>
		<script>

			const GL 			= WebGLRenderingContext.prototype;
			const NS 			= Symbol.for("GLElements");
			const GLOBAL 		= window[NS];
			const Resource 		= GLOBAL.Class.GLResource;
			const Context 		= GLOBAL.Class.GLContext;
			const Mesh 			= GLOBAL.Class.GLMesh;
			
			var ctx = new Context ( mainWindow, 1 );
			var program = ctx.createProgram();

			var vs = program.createShader( GL.VERTEX_SHADER );
			Resource.url( "test.vert" ).setTarget( vs.code );

			var fs = program.createShader( GL.FRAGMENT_SHADER );
			Resource.url( "test.frag" ).setTarget( fs.code );

			var mesh = new Mesh;
			
			Resource.url( "cube.obj" ).setTarget( Resource.parseObj() );

			var vertices = program.createVertexbuffer( GL.ARRAY_BUFFER,{
				index:0,
				size:2
			});

			var vertexSource = Resource.float32(
				 0,  0,
				-1,  1,
				-1, -1,
				 1, -1,
				 1,  1
			).setTarget( vertices.buffer );

			var colors = program.createVertexbuffer( GL.ARRAY_BUFFER,{
				index:1,
				size:4
			});
			colors.usage = GL.DYNAMIC_DRAW;
			var cBuffer = new Float32Array( 20 );
			colors.buffer.process( cBuffer );
			/*var colorSource = GLResource.float32(new Float32Array(16)
			).setTarget( colors.buffer );*/

			var indices = program.createVertexbuffer();
			var indexSource = Resource.uint16(
				0,1,2,0,3,0,4,0,1
			).setTarget( indices.buffer );

			var frame = 0;
			void function loop(){
				frame++;
				requestAnimationFrame(loop);
				
				cBuffer.set([
					0,
					0,
					0,
					1,
					(Math.sin(frame*.19)+1)*.5, 
					(Math.cos(-frame*.11)+1)*.5, 
					(Math.cos(frame*.13)+1)*.5, 
					1,
					(Math.cos(frame*.12)+1)*.5, 
					(Math.sin(-frame*.15)+1)*.5, 
					(Math.sin(frame*.1)+1)*.5, 
					1,
					(Math.cos(frame*.12)+1)*.5, 
					(Math.sin(frame*.11)+1)*.5, 
					(Math.cos(-frame*.1)+1)*.5, 
					1,
					(Math.sin(-frame*.1)+1)*.5, 
					(Math.cos(frame*.16)+1)*.5, 
					(Math.sin(frame*.122)+1)*.5, 
					1
				])
				colors.buffer.process( cBuffer );
				
				program.drawElements(GL.LINES,indices.SIZE / 2,GL.UNSIGNED_SHORT,0);
				//program.drawElements(GL.LINE_STRIP,indices.SIZE / 2,GL.UNSIGNED_SHORT,0);
			} ( )
		</script-->
<!--
<script>
			(function(){
				mainWindow.addEventListener("click",function(){
					mainWindow.requestPointerLock();
				}); 

			})()
		</script>
		<gl-context canvas="#mainWindow" quality="2">
			<camera-first-person id="view"></camera-first-person>
			<gl-mat4 		id="perspective" 	perspective="90,1,500"></gl-mat4>
			<gl-mat4 		id="model" 			translation="0,0,0"></gl-mat4>
			<gl-texture 	id="city" 			src="textest.jpg"></gl-texture>
			<gl-texture 	id="tree" 			src="textest.png"></gl-texture>
			<gl-geometry 	id="fsq" 			src="cube.obj"></gl-geometry>
			<gl-program 	id="fullscreenQuad">
				<gl-vertexbuffer 
					id="vertices" 
					target="ARRAY" 
					pointer="size:2,index:0"
					data="float32
						-1 -1
						 1 -1
						-1  1
						-1  1
						 1 -1
						 1  1
				"></gl-vertexbuffer>
				<gl-vertexbuffer 
					id="colorCoords" 
					target="ARRAY"
					pointer="size:4,index:1" 
					data="float32 
						1 1 1 1 
						0 1 0 1
						1 0 1 1
						1 0 1 1
						0 1 0 1
						0 0 0 1
				"></gl-vertexbuffer>

				<gl-shader 	type="VERTEX" id="VS" code="
					precision mediump float;
					#include url test.vert interval:15000;
					attribute vec2 vertices;
					attribute vec4 colorCoords;
					varying vec4 color;
					void main(void){
						gl_Position = vec4(vertices,0,1);
						color = colorCoords;
					}
				"></gl-shader>
				<gl-shader type="FRAGMENT" 		id="FS"	code="
					precision mediump float;
					varying vec4 color;
					void main(void){
						gl_FragColor = color;
					}
				"></gl-shader>
			</gl-program>
		</gl-context>
	Model
	value:{fun1(a,b),fun2(a,b}
	HTML
	value="fun1:argA,argB fun1:argA,argB fun2:argA,argB" 
	-> value.fun1(argA,argB).fun1(argA,argB).fun2(argA,argB);

	applications

	value="Float32:1,2,3,5,5" 
	the "value" property has a Float32 method that converts a string to a Float32 array.

	value="base16:FF,FF,A5,51 toUint16"
	the base16 method first interprets the string as as hexadecimal, returns a new arraylike object that has the method toUint16 that transforms it to a typed array.

	value="urL:index.html 



	<script src id="precision">
			#ifdef GL_ES
				precision mediump float;
				precision mediump int;
			#endif
		</script>
		<script src id="attributes">
			attribute vec4 id_fsq_v;
			attribute vec2 id_fsq_vt;
			attribute vec4 id_level_v;
			attribute vec2 id_level_vt;
		</script> 
		<script src id="varyings">
			varying vec2 texCoords;
		</script>
		<script src id="uniforms">
			uniform sampler2D tex0;
			uniform vec2 resolution;
			uniform vec2 mouse;
			uniform float time;
			uniform float frames;
			uniform mat4 perspective;
			uniform mat4 model;
			uniform mat4 view;
		</script>
		<script src id="sample">
			varying vec2 texCoords;
			vec4 sample(sampler2D texture){
				return texture2D(texture,texCoords);
			}
		</script>
		<script src id="matrixMath">
			mat4 rotationX(float angle){
				float s = sin(angle);
				float c = cos(angle);
				return mat4(
					1,	0,	0,	0,
					0,	c,  s,	0,
					0, -s,	c,	0,
					0,	0,	0,	1
				);
			}
			mat4 rotationY(float angle){
				float s = sin(angle);
				float c = cos(angle);
				return mat4(
					c,	0, -s,	0,
					0,	1, 	0,	0,
				    s,	0,	c,	0,
					0,	0,	0,	1
				);
			}
			mat4 rotationZ(float angle){
				float s = sin(angle);
				float c = cos(angle);
				return mat4(
					c,	s,	0,	0,
				   -s,	c,	0,	0,
					0,	0,	1,	0,
					0,	0,	0,	1
				);
			}
			mat4 scale(float x,float y,float z){
				return mat4(
					x,	0,	0,	0,
					0,	y,	0,	0,
					0,	0,	z,	0,
					0,	0,	0,	1
				);
			}
			mat4 transl(float x,float y,float z){
				return mat4(
					1,	0,	0,	0,
					0,	1,	0,	0,
					0,	0,	1,	0,
					x,	y,	z,	1
				);
			}
			mat4 frustrum(float left, float right,float bottom,float top, float near,float far){
				float x = 2.*near/(right-left);
				float y = 2.*near/(top-bottom);
				
				float a = (right+left)/(right-left);
				float b = (top+bottom)/(top-bottom);
				float c = -(far+near)/(far-near);
				float d = - 2.*far*near/(far-near);
				
				return mat4(
					x,	0,	0,	0,
					0,	y,	0,	0,
					a,	b,	c, -1,
					0,	0,  d,	0
				);
			}
			mat4 perspective(float fov,float aspect,float near,float far){
				const float PI = 3.14159265359;
				float ymax = near * tan(fov *PI / 360.);
				float ymin = -ymax;
				float xmin = ymin * aspect;
				float xmax = ymax * aspect;

				return frustrum(
					xmin,
					xmax,
					ymin,
					ymax,
					near,
					far
				);
			}
			mat4 identity(){
				return mat4(
					1,0,0,0,
					0,1,0,0,
					0,0,1,0,
					0,0,0,1
				);
			}
			mat4 inverse(mat4 M){
				float n11=M[0][0];float n21=M[1][0];float n31=M[2][0];float n41=M[3][0];
				float n12=M[0][1];float n22=M[1][1];float n32=M[2][1];float n42=M[3][1];
				float n13=M[0][2];float n23=M[1][2];float n33=M[2][2];float n43=M[3][2];
				float n14=M[0][3];float n24=M[1][3];float n34=M[2][3];float n44=M[3][3];

				M[0][0]	= n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 
						- n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44;
				M[0][1]	= n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 
						+ n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44;
				M[0][2]	= n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 
						- n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44;
				M[0][3]	= n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 
						+ n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;
				M[1][0]	= n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 
						+ n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44;
				M[1][1]	= n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 
						- n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44;
				M[1][2]	= n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 
						+ n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44;
				M[1][3]	= n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 
						- n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34;
				M[2][0]	= n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 
						- n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44;
				M[2][1]	= n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 
						+ n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44;
				M[2][2]	= n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 
						- n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44;
				M[2][3]	= n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 
						+ n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34;
				M[3][0]	= n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 
						+ n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43;
				M[3][1]	= n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 
						- n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43;
				M[3][2]	= n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 
						+ n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43;
				M[3][3]	= n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 
						- n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33;
				float det = n11 * M[0][0] + n21 * M[0][1] + n31 * M[0][2] + n41 * M[0][3];
				if(det == 0.){
					return identity();
				}
				else{
					return M * (1./det);
				}
			}
		</script>
	<gl-mat4
			identity
			id="perspective" 
			perspective="90,1,400"
		></gl-mat4>
		<gl-mat4 
			id="view"
			identity 
			rotationx="45"
			rotationy="45"
			inverse
		></gl-mat4>
	<script>
			(function(){
				const V = window["::gl-vector::"].FACTORIES;
				const vec2 = V.vec2;
				const vec3 = V.vec3;
				const quat4 = V.quat4;
				
				var lastFrame = 0;

				const UP = new vec3(0,1,0);
				const key = {UP:false,DOWN:false,LEFT:false,RIGHT:false,RAISE:false,LOWER:false}
				const mouse = vec2(0,0);

				const cameraPos = new vec3(0,0,0);
				const cameraDir = new vec3(0,0,1);

				const forwardDir 	= vec3.copy(cameraDir);
				const strafeDir 	= vec3.copy(cameraDir).cross(UP);
				
				const yawAxis 	= vec3.copy(UP);
				const pitchAxis 	= vec3.copy(cameraDir).cross(UP);

				const yaw = new quat4(0,0,0,1);
				const pitch = new quat4(0,0,0,1);

				const speed = .25;
				
				loop();
				document.addEventListener("keydown",function(e){
					//console.log(e.keyCode);
					const W = 87;
					const S = 83;
					const A = 65;
					const D = 68;
					const SPACE = 32;
					const SHIFT = 16;
					switch(e.keyCode){
						case W:
							key.UP = true;
						break;
						case S:
							key.DOWN = true;
						break;
						case A:
							key.LEFT = true;
						break;
						case D:
							key.RIGHT = true;
						break;
						case SPACE:
							key.RAISE = true;
						break;
						case SHIFT:
							key.LOWER = true;
						break;
					}
					
				});
				document.addEventListener("keyup",function(e){
					const W = 87;
					const S = 83;
					const A = 65;
					const D = 68;
					const SPACE = 32;
					const SHIFT = 16;
					switch(e.keyCode){
						case W:
							key.UP = false;
						break;
						case S:
							key.DOWN = false;
						break;
						case A:
							key.LEFT = false;
						break;
						case D:
							key.RIGHT = false;
						break;
						case SPACE:
							key.RAISE = false;
						break;
						case SHIFT:
							key.LOWER = false;
						break;
					}
				});
				document.addEventListener("mousemove",function(e){
					//console.log(e);
					mouse.x= -e.webkitMovementX/innerWidth;
					mouse.y= e.webkitMovementY/innerHeight;
					
				});
				function loop(){
					requestAnimationFrame(loop);
					updateView();
					lastFrame = Date.now();
				}
				function updateView(){
					//console.log(vec3.cross(cameraDir,UP).len);
					forwardDir.copy(cameraDir).norm();
					strafeDir.copy(cameraDir).cross(UP).norm();
					pitchAxis.copy(strafeDir);

					var deltaTime = Date.now()-lastFrame;
					var forwardScale = 0;
					var strafeScale = 0;
					forwardScale 	+= key.UP 		? 1 : 0;
					forwardScale 	-= key.DOWN 	? 1 : 0;
					strafeScale 	+= key.LEFT 	? 1 : 0;
					strafeScale 	-= key.RIGHT 	? 1 : 0;

					strafeDir.multScalar(strafeScale*speed*deltaTime);
					forwardDir.multScalar(forwardScale*speed*deltaTime);
					
					cameraPos.add(forwardDir);
					cameraPos.add(strafeDir);

					
					yaw.axisAngle(yawAxis,mouse.x);
					pitch.axisAngle(pitchAxis,mouse.y);
					
					cameraDir.applyQuat4(yaw);
					cameraDir.applyQuat4(pitch);

					mouse.x=0;
					mouse.y=0;
					
					
					view.matrix.position = cameraPos;
					view.matrix.lookAt(cameraPos,vec3.add(cameraPos,cameraDir),UP);
					
					view.matrix.inverse();
					view.value = view.matrix;
					
					
					
					
					
				}
			})()
		</script>
	<gl-framebuffer id="framebuffer">
		<gl-texture></gl-texture>
		<gl-program depth>
			<gl-shader vertex includes="#precision;#attributes" code="
				varying vec2 texCoords;
				
				void main(void){
					gl_Position = id_fsq_v;
					texCoords = id_fsq_vt;
				}
			"></gl-shader>
			<gl-shader fragment includes="#precision;#sample;#uniforms;#dist" code="
				uniform mat4 id_matrix;
				void main(void){
					vec2 p = gl_FragCoord.xy / resolution.xy - (vec4(mouse,0,0)*id_matrix).xy;
					p.x *= resolution.x / resolution.y;
					float a = atan(p.y, p.x);
					float r = length(p) + 0.0001;

					float b = 1.9 * sin(8.0 * r - 2.0 * a);
					b = 0.3125 / r + cos(7.0 * a + b * b) / (100.0 * r);
					b *= smoothstep(0.0, 0.4, b);

					gl_FragColor = vec4(b * .3, .3 * b + 0.2 * sin(a), b * 0.5, 1.0);
				}
			"></gl-shader>
		</gl-program>
	</gl-framebuffer>
	<gl-vertexbuffer id="pos" size="2" data="[
		-1,-1, 
		 1,-1, 
		-1, 1,
		-1, 1, 
		 1,-1, 
		 1, 1
	]"></gl-vertexbuffer>
	<gl-vertexbuffer id="color" size="4" data="[
		1,1,1,1,
        0,1,0,1,
        1,0,1,1,
        1,0,1,1,
        0,1,0,1,
        0,0,0,1
	]"></gl-vertexbuffer> 
-->