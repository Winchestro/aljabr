<!doctype html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
		<meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1.0, user-scalable=yes">
		<title>GLElements Test</title>
		<iframe src="bin/core.html"></iframe>
		<style>
			canvas {
				width : 100%;
				height : 100%;
				position: fixed;
				top : 0;
				left : 0;
				
				background : #000;
			}
			iframe {
				display : none;
			}
		</style>
	</head> 
	<body>
		<script>
		"use strict";
			var startTime = Date.now();
			var time,mesh,material,geometry,uniforms;

			function main() {
				
				canvas.width = innerWidth;
				canvas.height = innerHeight;
				gl.viewport( 0, 0, innerWidth, innerHeight );
				document.body.appendChild( canvas );
				let PI = Math.PI;
				let sin = Math.sin;
				Geometry.Sphere.options.colorIterator = function ( data, offset, latitude, longitude ) {
					data[ offset     ] = latitude; 
					data[ offset + 1 ] =  ( sin( longitude * PI ) + 1 ) * .5;
					data[ offset + 2 ] = 1. - latitude; 
					data[ offset + 3 ] = 1;
				},
				//mesh = new Geometry.Sphere;
				geometry = new Geometry.Sphere( "sphere", 100, 100 );
				
				material = geometry.material;
				material.depth.enableWrite().enable();
				//material.alpha.enable().setColor( .33, .9, .33, 1 ).setFunc( Alpha.FN_SRC_ALPHA, Alpha.FN_CONSTANT_COLOR );
				let programSource = new Program.DynamicSource( "../test", 1000 );
				programSource.setTarget( function ( program ) {
					material.program = program.bindLocations(
						"position",
						"color",
						"normal",
						"texCoord"
					).link().use();
					uniforms = program.getUniforms;
					if ( uniforms.projectionMatrix ) uniforms.projectionMatrix.set(
						mat4.Perspective(
							innerWidth / innerHeight,
							Math.PI / 3,
							.01,
							20 
						)/*
						mat4.Orthographic( 
							-innerWidth / 200,
							innerWidth / 200, 
							-innerHeight / 200,
							innerHeight / 200
							,
							.01,
							100 
						)*/
					);
					if ( uniforms.modelMatrix ) uniforms.modelMatrix.set(
						new mat4.Translation( 0, 0, -2 )//.rotate( Math.PI / 2, 0, 1, 1)
					);
					if ( uniforms.viewMatrix ) uniforms.viewMatrix.set(
						new mat4.Translation( 0, 0, 0 )
					);
					if ( uniforms.modelScale ) uniforms.modelScale.set(
						[ 1, 1, 1 ]
					);
					if ( uniforms.tex0 ) uniforms.tex0.location.set1i( 0 );
				} );
				uniforms = material.program.getUniforms;
				loop();
			}
			function loop ( ) {
				requestAnimationFrame( loop );
				draw();
			};
			window.ADDS = 300;
			window.MULTS = Math.PI;
			window.LEN = 26;
			window.CALLS = 300;
			window.DIVS = 1;
			function draw ( ) {	

				geometry.use();
				time = Date.now() - startTime;

				Draw.clear( gl.COLOR_BUFFER_BIT  | gl.DEPTH_BUFFER_BIT );
				if( uniforms.time ) uniforms.time.set( time );
				
				if ( uniforms.modelMatrix ){
					uniforms.modelMatrix.value.rotate( 
						0.01,
						Math.sin( time * 0.001 ),
						Math.cos( time * 0.002 ),
						Math.sin( time * 0.003 )
					);
					uniforms.modelMatrix.set();
				}
				let length = geometry.getLength;
				//geometry.draw();
				let t = time / 60;
				for ( let i = 1; i < CALLS - Math.sin( time / 1000 ) * 200; i++ ) {
					let start = ( Math.sin( ( t + 10 ) / ( i + ADDS * MULTS ) ) + 1 ) * length / 2 ;
					let count = LEN + Math.cos( time / 1000 ) * 25;
					geometry.draw( Math.max( start  % length, 0  ) , Math.min( count, length - start ) ); 
				}
				
				/*
				geometry.draw( range, ( ( r2 / range ) + 15 ) % ( length - range ) ); 

				range = ( Math.sin( time / 500 ) + 1 ) * length / 2 ;
				r2 = Math.abs( ( Math.sin( time / 500 )  ) * length ) 
				geometry.draw( range, ( ( r2 / range ) + 15 ) % ( length - range ) ); 

				range = ( Math.sin( time / 400 ) + 1 ) * length / 2 ;
				r2 = Math.abs( ( Math.sin( time / 500 )  ) * length ) 
				geometry.draw( range, ( ( r2 / range ) + 15 ) % ( length - range ) ); 

				range = ( Math.sin( time / 300 ) + 1 ) * length / 2 ;
				r2 = Math.abs( ( Math.sin( time / 500 )  ) * length ) 
				geometry.draw( range, ( ( r2 / range ) + 15 ) % ( length - range ) ); 
				*/
				
			};
		</script>
	</body>
</html>
<!--canvas id="mainWindow"></canvas>
		<script>
			/*
				window.el = document.createElement("button");
				el.innerText = "abcd";
				el.style.background = "yellowgreen";
				el.style.color = "white";
				window.texture = new Texture;
				function generateTestTex( a, b) {
					let data = new Uint8Array( [ a,a,a,255, b,b,b,255, a,a,a,255, b,b,b,255 ] );
					texture
					.bind()
					.texData( data, 2, 2 )
					.setActiveTexture( 0 );
					return data;
				}
				window.generateTestTex = generateTestTex;
				//console.log( generateTestTex( 60, 180 ) );

				function htmlToTex( element ) {
					window.htmlResource = new Resource.htmlTexture( element );
					htmlResource.setTarget( function( img ) { 
						texture
						.bind()
						.texImage( img )
						.setWrapS()
						.setWrapT()
						.setMagFilter()
						.setMinFilter()
						//.pixelStorei( gl.UNPACK_FLIP_Y_WEBGL, true )
						.setActiveTexture( 0 );
					});
					
					
					
				}
				window.htmlToTex = htmlToTex;
				//htmlToTex( el );

				window.objectSource = new Resource.http( "../cube.obj", { interval : 1000 } )
				.setTarget( new Resource.parseObj()
					.setTarget( new Resource( function ( scene ) {
						//console.log( scene );		
						for ( var object in scene ) {
							var obj = scene[ object ];
							var length = Math.max( 
								obj.v ? obj.v.length : 0,
								obj.vt ? obj.vt.length : 0,
								obj.vn ? obj.vn.length : 0 
							);
							var structure = [];
							if ( obj.v ) structure.push( new Float32Array( obj.v[0].length ) );
							if ( obj.vt ) structure.push( new Float32Array( obj.vt[0].length ) );
							if ( obj.vn ) structure.push( new Float32Array( obj.vn[0].length ) );
							structure.push( new Float32Array( 3 ) );
							//console.log( length );
							window.geometry = new Geometry().createVertexAttributeGroup(
								object,
								structure,
								length
							);
							var view = geometry[ object ].view;
							var stride = geometry[ object ].data.stride / 4;
							var index = new Uint16Array( obj.f.length * 3 );
							var offset = 0;
							var UV = [];
							var Normals = [];
							for ( var face of obj.f ) {
								if ( obj.vt ) {
									UV[ face [ 0 ][ 0 ] ] = UV[ face [ 0 ][ 0 ] ] || obj.vt[ face[ 0 ][ 1 ] ];
									UV[ face [ 1 ][ 0 ] ] = UV[ face [ 1 ][ 0 ] ] || obj.vt[ face[ 1 ][ 1 ] ];
									UV[ face [ 2 ][ 0 ] ] = UV[ face [ 2 ][ 0 ] ] || obj.vt[ face[ 2 ][ 1 ] ];
								}
								if ( obj.vn ) {
									Normals[ face [ 0 ][ 0 ] + 1 ] = obj.vn[ face[ 0 ][ 2 ] + 1 ];
									Normals[ face [ 1 ][ 0 ] + 1 ] = obj.vn[ face[ 1 ][ 2 ] + 1 ];
									Normals[ face [ 2 ][ 0 ] + 1 ] = obj.vn[ face[ 2 ][ 2 ] + 1 ];
								}
								index.set( [
									face[ 0 ][ 0 ],
									face[ 1 ][ 0 ],
									face[ 2 ][ 0 ]
								], offset );
								

								offset += 3;
							}
							//console.log( obj, UV );
							offset = 0;
							for ( var i in obj.v ) {
								var data = [];
								data.push.apply( data, obj.v[ i ] );
								if ( obj.vt ) data.push.apply( data, UV[ i ] );
								if ( obj.vn ) data.push.apply( data, Normals[ i ] );
								data.push( Math.random(), Math.random(), Math.random() );
								view.set( data, offset );
								//console.log( data );
								offset += stride;
							}
							geometry[ object ].set( view );
							geometry.createElementAttribute( object + "Triangles", index, material, gl.TRIANGLES );
							

							//geometry.createElementAttribute( object + "Points", gl.POINTS );
							window.geometry = geometry;
							//console.log( geometry, index );
						}
					} ) ) 
				)
				*/
				/*
				window.programSource = new Program.DynamicSource( "../test" );
				var init = false;
				programSource.setTarget( function ( program ) {
					
					console.log( "update" );
				} );
				*/
				//window.program = material.program;
				//window.uniforms = program.getUniforms;
				/*
				window.firstVertex = geometry.dynamic.createVertexView( 1 );

				uniforms.projectionMatrix.set(
					mat4.Perspective( innerWidth / innerHeight, 90, 0.1, 10 ) 
				);
				uniforms.modelMatrix.set(
					new mat4
				);
				uniforms.viewMatrix.set(
					new mat4().translate( 1, 1, 1 ).invert()
				);
				
				*/
				
				/*
						colors.bind();
						colors.data.set([
							(Math.sin(frame*.19)+1)*.5, 
							(Math.cos(-frame*.11)+1)*.5, 
							(Math.cos(frame*.13)+1)*.5, 
							1,
							(Math.cos(frame*.12)+1)*.5, 
							(Math.sin(-frame*.15)+1)*.5, 
							(Math.sin(frame*.1)+1)*.5, 
							1,
							(Math.cos(frame*.12)+1)*.5, 
							(Math.sin(frame*.11)+1)*.5, 
							(Math.cos(-frame*.1)+1)*.5, 
							1,
							(Math.sin(-frame*.1)+1)*.5, 
							(Math.cos(frame*.16)+1)*.5, 
							(Math.sin(frame*.122)+1)*.5, 
							1
						])
						colors.bufferSubData( 0, colors.data );
					*/
					
				float f = ( sin( float(frame)*.02 ) + 2. ) * 12.5 ;
				vec2 uv = gl_FragCoord.xy / resolution.xx;
				
				vec2 c =   ( uv - .5) * zoom - mouse;

				vec2 z = c;
				
				for ( int i = 0; i < maxIterations; i++  ){
					if( float(i) > f ) break;

					float x = ( z.x * z.x - z.y * z.y ) + c.x;
					float y = ( z.y * z.x + z.x * z.y ) + c.y;

					if ( ( x * x + y * y ) > ( (2.-zoom) * 4.) ) break;
					z.x = x;
					z.y = y;


					
					iterations += 1.;
				}
			const GL 			= WebGLRenderingContext.prototype;
			const NS 			= Symbol.for("GLElements");
			const GLOBAL 		= window[NS];
			const Resource 		= GLOBAL.Class.GLResource;
			const Context 		= GLOBAL.Class.GLContext;
			const Mesh 			= GLOBAL.Class.GLMesh;
			
			var ctx = new Context ( mainWindow, 1 );
			var program = ctx.createProgram();

			var vs = program.createShader( GL.VERTEX_SHADER );
			Resource.url( "test.vert" ).setTarget( vs.code );

			var fs = program.createShader( GL.FRAGMENT_SHADER );
			Resource.url( "test.frag" ).setTarget( fs.code );

			var mesh = new Mesh;
			
			Resource.url( "cube.obj" ).setTarget( Resource.parseObj() );

			var vertices = program.createVertexbuffer( GL.ARRAY_BUFFER,{
				index:0,
				size:2
			});

			var vertexSource = Resource.float32(
				 0,  0,
				-1,  1,
				-1, -1,
				 1, -1,
				 1,  1
			).setTarget( vertices.buffer );

			var colors = program.createVertexbuffer( GL.ARRAY_BUFFER,{
				index:1,
				size:4
			});
			colors.usage = GL.DYNAMIC_DRAW;
			var cBuffer = new Float32Array( 20 );
			colors.buffer.process( cBuffer );
			/*var colorSource = GLResource.float32(new Float32Array(16)
			).setTarget( colors.buffer );*/

			var indices = program.createVertexbuffer();
			var indexSource = Resource.uint16(
				0,1,2,0,3,0,4,0,1
			).setTarget( indices.buffer );

			var frame = 0;
			void function loop(){
				frame++;
				requestAnimationFrame(loop);
				
				cBuffer.set([
					0,
					0,
					0,
					1,
					(Math.sin(frame*.19)+1)*.5, 
					(Math.cos(-frame*.11)+1)*.5, 
					(Math.cos(frame*.13)+1)*.5, 
					1,
					(Math.cos(frame*.12)+1)*.5, 
					(Math.sin(-frame*.15)+1)*.5, 
					(Math.sin(frame*.1)+1)*.5, 
					1,
					(Math.cos(frame*.12)+1)*.5, 
					(Math.sin(frame*.11)+1)*.5, 
					(Math.cos(-frame*.1)+1)*.5, 
					1,
					(Math.sin(-frame*.1)+1)*.5, 
					(Math.cos(frame*.16)+1)*.5, 
					(Math.sin(frame*.122)+1)*.5, 
					1
				])
				colors.buffer.process( cBuffer );
				
				program.drawElements(GL.LINES,indices.SIZE / 2,GL.UNSIGNED_SHORT,0);
				//program.drawElements(GL.LINE_STRIP,indices.SIZE / 2,GL.UNSIGNED_SHORT,0);
			} ( )
		</script-->
<!--
<script>
			(function(){
				mainWindow.addEventListener("click",function(){
					mainWindow.requestPointerLock();
				}); 

			})()
		</script>
		<gl-context canvas="#mainWindow" quality="2">
			<camera-first-person id="view"></camera-first-person>
			<gl-mat4 		id="perspective" 	perspective="90,1,500"></gl-mat4>
			<gl-mat4 		id="model" 			translation="0,0,0"></gl-mat4>
			<gl-texture 	id="city" 			src="textest.jpg"></gl-texture>
			<gl-texture 	id="tree" 			src="textest.png"></gl-texture>
			<gl-geometry 	id="fsq" 			src="cube.obj"></gl-geometry>
			<gl-program 	id="fullscreenQuad">
				<gl-vertexbuffer 
					id="vertices" 
					target="ARRAY" 
					pointer="size:2,index:0"
					data="float32
						-1 -1
						 1 -1
						-1  1
						-1  1
						 1 -1
						 1  1
				"></gl-vertexbuffer>
				<gl-vertexbuffer 
					id="colorCoords" 
					target="ARRAY"
					pointer="size:4,index:1" 
					data="float32 
						1 1 1 1 
						0 1 0 1
						1 0 1 1
						1 0 1 1
						0 1 0 1
						0 0 0 1
				"></gl-vertexbuffer>

				<gl-shader 	type="VERTEX" id="VS" code="
					precision mediump float;
					#include url test.vert interval:15000;
					attribute vec2 vertices;
					attribute vec4 colorCoords;
					varying vec4 color;
					void main(void){
						gl_Position = vec4(vertices,0,1);
						color = colorCoords;
					}
				"></gl-shader>
				<gl-shader type="FRAGMENT" 		id="FS"	code="
					precision mediump float;
					varying vec4 color;
					void main(void){
						gl_FragColor = color;
					}
				"></gl-shader>
			</gl-program>
		</gl-context>
	Model
	value:{fun1(a,b),fun2(a,b}
	HTML
	value="fun1:argA,argB fun1:argA,argB fun2:argA,argB" 
	-> value.fun1(argA,argB).fun1(argA,argB).fun2(argA,argB);

	applications

	value="Float32:1,2,3,5,5" 
	the "value" property has a Float32 method that converts a string to a Float32 array.

	value="base16:FF,FF,A5,51 toUint16"
	the base16 method first interprets the string as as hexadecimal, returns a new arraylike object that has the method toUint16 that transforms it to a typed array.

	value="urL:index.html 



	<script src id="precision">
			#ifdef GL_ES
				precision mediump float;
				precision mediump int;
			#endif
		</script>
		<script src id="attributes">
			attribute vec4 id_fsq_v;
			attribute vec2 id_fsq_vt;
			attribute vec4 id_level_v;
			attribute vec2 id_level_vt;
		</script> 
		<script src id="varyings">
			varying vec2 texCoords;
		</script>
		<script src id="uniforms">
			uniform sampler2D tex0;
			uniform vec2 resolution;
			uniform vec2 mouse;
			uniform float time;
			uniform float frames;
			uniform mat4 perspective;
			uniform mat4 model;
			uniform mat4 view;
		</script>
		<script src id="sample">
			varying vec2 texCoords;
			vec4 sample(sampler2D texture){
				return texture2D(texture,texCoords);
			}
		</script>
		<script src id="matrixMath">
			mat4 rotationX(float angle){
				float s = sin(angle);
				float c = cos(angle);
				return mat4(
					1,	0,	0,	0,
					0,	c,  s,	0,
					0, -s,	c,	0,
					0,	0,	0,	1
				);
			}
			mat4 rotationY(float angle){
				float s = sin(angle);
				float c = cos(angle);
				return mat4(
					c,	0, -s,	0,
					0,	1, 	0,	0,
				    s,	0,	c,	0,
					0,	0,	0,	1
				);
			}
			mat4 rotationZ(float angle){
				float s = sin(angle);
				float c = cos(angle);
				return mat4(
					c,	s,	0,	0,
				   -s,	c,	0,	0,
					0,	0,	1,	0,
					0,	0,	0,	1
				);
			}
			mat4 scale(float x,float y,float z){
				return mat4(
					x,	0,	0,	0,
					0,	y,	0,	0,
					0,	0,	z,	0,
					0,	0,	0,	1
				);
			}
			mat4 transl(float x,float y,float z){
				return mat4(
					1,	0,	0,	0,
					0,	1,	0,	0,
					0,	0,	1,	0,
					x,	y,	z,	1
				);
			}
			mat4 frustrum(float left, float right,float bottom,float top, float near,float far){
				float x = 2.*near/(right-left);
				float y = 2.*near/(top-bottom);
				
				float a = (right+left)/(right-left);
				float b = (top+bottom)/(top-bottom);
				float c = -(far+near)/(far-near);
				float d = - 2.*far*near/(far-near);
				
				return mat4(
					x,	0,	0,	0,
					0,	y,	0,	0,
					a,	b,	c, -1,
					0,	0,  d,	0
				);
			}
			mat4 perspective(float fov,float aspect,float near,float far){
				const float PI = 3.14159265359;
				float ymax = near * tan(fov *PI / 360.);
				float ymin = -ymax;
				float xmin = ymin * aspect;
				float xmax = ymax * aspect;

				return frustrum(
					xmin,
					xmax,
					ymin,
					ymax,
					near,
					far
				);
			}
			mat4 identity(){
				return mat4(
					1,0,0,0,
					0,1,0,0,
					0,0,1,0,
					0,0,0,1
				);
			}
			mat4 inverse(mat4 M){
				float n11=M[0][0];float n21=M[1][0];float n31=M[2][0];float n41=M[3][0];
				float n12=M[0][1];float n22=M[1][1];float n32=M[2][1];float n42=M[3][1];
				float n13=M[0][2];float n23=M[1][2];float n33=M[2][2];float n43=M[3][2];
				float n14=M[0][3];float n24=M[1][3];float n34=M[2][3];float n44=M[3][3];

				M[0][0]	= n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 
						- n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44;
				M[0][1]	= n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 
						+ n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44;
				M[0][2]	= n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 
						- n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44;
				M[0][3]	= n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 
						+ n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;
				M[1][0]	= n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 
						+ n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44;
				M[1][1]	= n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 
						- n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44;
				M[1][2]	= n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 
						+ n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44;
				M[1][3]	= n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 
						- n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34;
				M[2][0]	= n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 
						- n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44;
				M[2][1]	= n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 
						+ n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44;
				M[2][2]	= n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 
						- n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44;
				M[2][3]	= n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 
						+ n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34;
				M[3][0]	= n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 
						+ n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43;
				M[3][1]	= n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 
						- n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43;
				M[3][2]	= n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 
						+ n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43;
				M[3][3]	= n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 
						- n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33;
				float det = n11 * M[0][0] + n21 * M[0][1] + n31 * M[0][2] + n41 * M[0][3];
				if(det == 0.){
					return identity();
				}
				else{
					return M * (1./det);
				}
			}
		</script>
	<gl-mat4
			identity
			id="perspective" 
			perspective="90,1,400"
		></gl-mat4>
		<gl-mat4 
			id="view"
			identity 
			rotationx="45"
			rotationy="45"
			inverse
		></gl-mat4>
	<script>
			(function(){
				const V = window["::gl-vector::"].FACTORIES;
				const vec2 = V.vec2;
				const vec3 = V.vec3;
				const quat4 = V.quat4;
				
				var lastFrame = 0;

				const UP = new vec3(0,1,0);
				const key = {UP:false,DOWN:false,LEFT:false,RIGHT:false,RAISE:false,LOWER:false}
				const mouse = vec2(0,0);

				const cameraPos = new vec3(0,0,0);
				const cameraDir = new vec3(0,0,1);

				const forwardDir 	= vec3.copy(cameraDir);
				const strafeDir 	= vec3.copy(cameraDir).cross(UP);
				
				const yawAxis 	= vec3.copy(UP);
				const pitchAxis 	= vec3.copy(cameraDir).cross(UP);

				const yaw = new quat4(0,0,0,1);
				const pitch = new quat4(0,0,0,1);

				const speed = .25;
				
				loop();
				document.addEventListener("keydown",function(e){
					//console.log(e.keyCode);
					const W = 87;
					const S = 83;
					const A = 65;
					const D = 68;
					const SPACE = 32;
					const SHIFT = 16;
					switch(e.keyCode){
						case W:
							key.UP = true;
						break;
						case S:
							key.DOWN = true;
						break;
						case A:
							key.LEFT = true;
						break;
						case D:
							key.RIGHT = true;
						break;
						case SPACE:
							key.RAISE = true;
						break;
						case SHIFT:
							key.LOWER = true;
						break;
					}
					
				});
				document.addEventListener("keyup",function(e){
					const W = 87;
					const S = 83;
					const A = 65;
					const D = 68;
					const SPACE = 32;
					const SHIFT = 16;
					switch(e.keyCode){
						case W:
							key.UP = false;
						break;
						case S:
							key.DOWN = false;
						break;
						case A:
							key.LEFT = false;
						break;
						case D:
							key.RIGHT = false;
						break;
						case SPACE:
							key.RAISE = false;
						break;
						case SHIFT:
							key.LOWER = false;
						break;
					}
				});
				document.addEventListener("mousemove",function(e){
					//console.log(e);
					mouse.x= -e.webkitMovementX/innerWidth;
					mouse.y= e.webkitMovementY/innerHeight;
					
				});
				function loop(){
					requestAnimationFrame(loop);
					updateView();
					lastFrame = Date.now();
				}
				function updateView(){
					//console.log(vec3.cross(cameraDir,UP).len);
					forwardDir.copy(cameraDir).norm();
					strafeDir.copy(cameraDir).cross(UP).norm();
					pitchAxis.copy(strafeDir);

					var deltaTime = Date.now()-lastFrame;
					var forwardScale = 0;
					var strafeScale = 0;
					forwardScale 	+= key.UP 		? 1 : 0;
					forwardScale 	-= key.DOWN 	? 1 : 0;
					strafeScale 	+= key.LEFT 	? 1 : 0;
					strafeScale 	-= key.RIGHT 	? 1 : 0;

					strafeDir.multScalar(strafeScale*speed*deltaTime);
					forwardDir.multScalar(forwardScale*speed*deltaTime);
					
					cameraPos.add(forwardDir);
					cameraPos.add(strafeDir);

					
					yaw.axisAngle(yawAxis,mouse.x);
					pitch.axisAngle(pitchAxis,mouse.y);
					
					cameraDir.applyQuat4(yaw);
					cameraDir.applyQuat4(pitch);

					mouse.x=0;
					mouse.y=0;
					
					
					view.matrix.position = cameraPos;
					view.matrix.lookAt(cameraPos,vec3.add(cameraPos,cameraDir),UP);
					
					view.matrix.inverse();
					view.value = view.matrix;
					
					
					
					
					
				}
			})()
		</script>
	<gl-framebuffer id="framebuffer">
		<gl-texture></gl-texture>
		<gl-program depth>
			<gl-shader vertex includes="#precision;#attributes" code="
				varying vec2 texCoords;
				
				void main(void){
					gl_Position = id_fsq_v;
					texCoords = id_fsq_vt;
				}
			"></gl-shader>
			<gl-shader fragment includes="#precision;#sample;#uniforms;#dist" code="
				uniform mat4 id_matrix;
				void main(void){
					vec2 p = gl_FragCoord.xy / resolution.xy - (vec4(mouse,0,0)*id_matrix).xy;
					p.x *= resolution.x / resolution.y;
					float a = atan(p.y, p.x);
					float r = length(p) + 0.0001;

					float b = 1.9 * sin(8.0 * r - 2.0 * a);
					b = 0.3125 / r + cos(7.0 * a + b * b) / (100.0 * r);
					b *= smoothstep(0.0, 0.4, b);

					gl_FragColor = vec4(b * .3, .3 * b + 0.2 * sin(a), b * 0.5, 1.0);
				}
			"></gl-shader>
		</gl-program>
	</gl-framebuffer>
	<gl-vertexbuffer id="pos" size="2" data="[
		-1,-1, 
		 1,-1, 
		-1, 1,
		-1, 1, 
		 1,-1, 
		 1, 1
	]"></gl-vertexbuffer>
	<gl-vertexbuffer id="color" size="4" data="[
		1,1,1,1,
        0,1,0,1,
        1,0,1,1,
        1,0,1,1,
        0,1,0,1,
        0,0,0,1
	]"></gl-vertexbuffer> 
-->