<!doctype html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
		<meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1.0, user-scalable=yes">
		<title>GLElements Test</title>
  
		<link rel="import" href="gl-elements.html">
		<style>
			canvas{
				width:100%;
				height:100%;
				position:fixed;
				top:0;
				left:0;
				background:#444;
			}
		</style>
		 
	</head> 
	<body>
		<canvas id="mainWindow"></canvas>
		<script>
			(function(){
				mainWindow.addEventListener("click",function(){
					mainWindow.requestPointerLock();
				}); 

			})()
		</script>
		<gl-context canvas="#mainWindow" quality="2">
			<camera-first-person id="view"></camera-first-person>
			<gl-mat4 		id="perspective" 	perspective="90,1,500"></gl-mat4>
			<gl-mat4 		id="model" 			translation="0,0,0"></gl-mat4>
			<gl-texture 	id="city" 			src="textest.jpg"></gl-texture>
			<gl-texture 	id="tree" 			src="textest.png"></gl-texture>
			<gl-geometry 	id="fsq" 			src="cube.obj"></gl-geometry>
			<gl-program 	id="fullscreenQuad">
				<gl-vertexbuffer id="vertices" target="ARRAY" size="2" data="Float32:
					-1 -1
					 1 -1
					-1  1
					-1  1
					 1 -1
					 1  1
				"></gl-vertexbuffer>
				<gl-vertexbuffer id="colorCoords" target="ARRAY" size="4" data="Float32:
					1 1 1 1
					0 1 0 1
					1 0 1 1
					1 0 1 1
					0 1 0 1
					0 0 0 1
				"></gl-vertexbuffer>
				<gl-shader 	type="VERTEX" 		id="VS"	src="test.vert"></gl-shader>
				<gl-shader type="FRAGMENT" 		id="FS"	src="test.frag"></gl-shader>
			</gl-program>
		</gl-context>

	</body>
</html>
<!--

	Model
	value:{fun1(a,b),fun2(a,b}
	HTML
	value="fun1:argA,argB fun1:argA,argB fun2:argA,argB" 
	-> value.fun1(argA,argB).fun1(argA,argB).fun2(argA,argB);

	applications

	value="Float32:1,2,3,5,5" 
	the "value" property has a Float32 method that converts a string to a Float32 array.

	value="base16:FF,FF,A5,51 toUint16"
	the base16 method first interprets the string as as hexadecimal, returns a new arraylike object that has the method toUint16 that transforms it to a typed array.

	value="urL:index.html 



	<script src id="precision">
			#ifdef GL_ES
				precision mediump float;
				precision mediump int;
			#endif
		</script>
		<script src id="attributes">
			attribute vec4 id_fsq_v;
			attribute vec2 id_fsq_vt;
			attribute vec4 id_level_v;
			attribute vec2 id_level_vt;
		</script> 
		<script src id="varyings">
			varying vec2 texCoords;
		</script>
		<script src id="uniforms">
			uniform sampler2D tex0;
			uniform vec2 resolution;
			uniform vec2 mouse;
			uniform float time;
			uniform float frames;
			uniform mat4 perspective;
			uniform mat4 model;
			uniform mat4 view;
		</script>
		<script src id="sample">
			varying vec2 texCoords;
			vec4 sample(sampler2D texture){
				return texture2D(texture,texCoords);
			}
		</script>
		<script src id="matrixMath">
			mat4 rotationX(float angle){
				float s = sin(angle);
				float c = cos(angle);
				return mat4(
					1,	0,	0,	0,
					0,	c,  s,	0,
					0, -s,	c,	0,
					0,	0,	0,	1
				);
			}
			mat4 rotationY(float angle){
				float s = sin(angle);
				float c = cos(angle);
				return mat4(
					c,	0, -s,	0,
					0,	1, 	0,	0,
				    s,	0,	c,	0,
					0,	0,	0,	1
				);
			}
			mat4 rotationZ(float angle){
				float s = sin(angle);
				float c = cos(angle);
				return mat4(
					c,	s,	0,	0,
				   -s,	c,	0,	0,
					0,	0,	1,	0,
					0,	0,	0,	1
				);
			}
			mat4 scale(float x,float y,float z){
				return mat4(
					x,	0,	0,	0,
					0,	y,	0,	0,
					0,	0,	z,	0,
					0,	0,	0,	1
				);
			}
			mat4 transl(float x,float y,float z){
				return mat4(
					1,	0,	0,	0,
					0,	1,	0,	0,
					0,	0,	1,	0,
					x,	y,	z,	1
				);
			}
			mat4 frustrum(float left, float right,float bottom,float top, float near,float far){
				float x = 2.*near/(right-left);
				float y = 2.*near/(top-bottom);
				
				float a = (right+left)/(right-left);
				float b = (top+bottom)/(top-bottom);
				float c = -(far+near)/(far-near);
				float d = - 2.*far*near/(far-near);
				
				return mat4(
					x,	0,	0,	0,
					0,	y,	0,	0,
					a,	b,	c, -1,
					0,	0,  d,	0
				);
			}
			mat4 perspective(float fov,float aspect,float near,float far){
				const float PI = 3.14159265359;
				float ymax = near * tan(fov *PI / 360.);
				float ymin = -ymax;
				float xmin = ymin * aspect;
				float xmax = ymax * aspect;

				return frustrum(
					xmin,
					xmax,
					ymin,
					ymax,
					near,
					far
				);
			}
			mat4 identity(){
				return mat4(
					1,0,0,0,
					0,1,0,0,
					0,0,1,0,
					0,0,0,1
				);
			}
			mat4 inverse(mat4 M){
				float n11=M[0][0];float n21=M[1][0];float n31=M[2][0];float n41=M[3][0];
				float n12=M[0][1];float n22=M[1][1];float n32=M[2][1];float n42=M[3][1];
				float n13=M[0][2];float n23=M[1][2];float n33=M[2][2];float n43=M[3][2];
				float n14=M[0][3];float n24=M[1][3];float n34=M[2][3];float n44=M[3][3];

				M[0][0]	= n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 
						- n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44;
				M[0][1]	= n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 
						+ n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44;
				M[0][2]	= n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 
						- n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44;
				M[0][3]	= n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 
						+ n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;
				M[1][0]	= n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 
						+ n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44;
				M[1][1]	= n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 
						- n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44;
				M[1][2]	= n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 
						+ n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44;
				M[1][3]	= n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 
						- n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34;
				M[2][0]	= n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 
						- n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44;
				M[2][1]	= n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 
						+ n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44;
				M[2][2]	= n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 
						- n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44;
				M[2][3]	= n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 
						+ n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34;
				M[3][0]	= n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 
						+ n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43;
				M[3][1]	= n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 
						- n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43;
				M[3][2]	= n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 
						+ n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43;
				M[3][3]	= n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 
						- n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33;
				float det = n11 * M[0][0] + n21 * M[0][1] + n31 * M[0][2] + n41 * M[0][3];
				if(det == 0.){
					return identity();
				}
				else{
					return M * (1./det);
				}
			}
		</script>
	<gl-mat4
			identity
			id="perspective" 
			perspective="90,1,400"
		></gl-mat4>
		<gl-mat4 
			id="view"
			identity 
			rotationx="45"
			rotationy="45"
			inverse
		></gl-mat4>
	<script>
			(function(){
				const V = window["::gl-vector::"].FACTORIES;
				const vec2 = V.vec2;
				const vec3 = V.vec3;
				const quat4 = V.quat4;
				
				var lastFrame = 0;

				const UP = new vec3(0,1,0);
				const key = {UP:false,DOWN:false,LEFT:false,RIGHT:false,RAISE:false,LOWER:false}
				const mouse = vec2(0,0);

				const cameraPos = new vec3(0,0,0);
				const cameraDir = new vec3(0,0,1);

				const forwardDir 	= vec3.copy(cameraDir);
				const strafeDir 	= vec3.copy(cameraDir).cross(UP);
				
				const yawAxis 	= vec3.copy(UP);
				const pitchAxis 	= vec3.copy(cameraDir).cross(UP);

				const yaw = new quat4(0,0,0,1);
				const pitch = new quat4(0,0,0,1);

				const speed = .25;
				
				loop();
				document.addEventListener("keydown",function(e){
					//console.log(e.keyCode);
					const W = 87;
					const S = 83;
					const A = 65;
					const D = 68;
					const SPACE = 32;
					const SHIFT = 16;
					switch(e.keyCode){
						case W:
							key.UP = true;
						break;
						case S:
							key.DOWN = true;
						break;
						case A:
							key.LEFT = true;
						break;
						case D:
							key.RIGHT = true;
						break;
						case SPACE:
							key.RAISE = true;
						break;
						case SHIFT:
							key.LOWER = true;
						break;
					}
					
				});
				document.addEventListener("keyup",function(e){
					const W = 87;
					const S = 83;
					const A = 65;
					const D = 68;
					const SPACE = 32;
					const SHIFT = 16;
					switch(e.keyCode){
						case W:
							key.UP = false;
						break;
						case S:
							key.DOWN = false;
						break;
						case A:
							key.LEFT = false;
						break;
						case D:
							key.RIGHT = false;
						break;
						case SPACE:
							key.RAISE = false;
						break;
						case SHIFT:
							key.LOWER = false;
						break;
					}
				});
				document.addEventListener("mousemove",function(e){
					//console.log(e);
					mouse.x= -e.webkitMovementX/innerWidth;
					mouse.y= e.webkitMovementY/innerHeight;
					
				});
				function loop(){
					requestAnimationFrame(loop);
					updateView();
					lastFrame = Date.now();
				}
				function updateView(){
					//console.log(vec3.cross(cameraDir,UP).len);
					forwardDir.copy(cameraDir).norm();
					strafeDir.copy(cameraDir).cross(UP).norm();
					pitchAxis.copy(strafeDir);

					var deltaTime = Date.now()-lastFrame;
					var forwardScale = 0;
					var strafeScale = 0;
					forwardScale 	+= key.UP 		? 1 : 0;
					forwardScale 	-= key.DOWN 	? 1 : 0;
					strafeScale 	+= key.LEFT 	? 1 : 0;
					strafeScale 	-= key.RIGHT 	? 1 : 0;

					strafeDir.multScalar(strafeScale*speed*deltaTime);
					forwardDir.multScalar(forwardScale*speed*deltaTime);
					
					cameraPos.add(forwardDir);
					cameraPos.add(strafeDir);

					
					yaw.axisAngle(yawAxis,mouse.x);
					pitch.axisAngle(pitchAxis,mouse.y);
					
					cameraDir.applyQuat4(yaw);
					cameraDir.applyQuat4(pitch);

					mouse.x=0;
					mouse.y=0;
					
					
					view.matrix.position = cameraPos;
					view.matrix.lookAt(cameraPos,vec3.add(cameraPos,cameraDir),UP);
					
					view.matrix.inverse();
					view.value = view.matrix;
					
					
					
					
					
				}
			})()
		</script>
	<gl-framebuffer id="framebuffer">
		<gl-texture></gl-texture>
		<gl-program depth>
			<gl-shader vertex includes="#precision;#attributes" code="
				varying vec2 texCoords;
				
				void main(void){
					gl_Position = id_fsq_v;
					texCoords = id_fsq_vt;
				}
			"></gl-shader>
			<gl-shader fragment includes="#precision;#sample;#uniforms;#dist" code="
				uniform mat4 id_matrix;
				void main(void){
					vec2 p = gl_FragCoord.xy / resolution.xy - (vec4(mouse,0,0)*id_matrix).xy;
					p.x *= resolution.x / resolution.y;
					float a = atan(p.y, p.x);
					float r = length(p) + 0.0001;

					float b = 1.9 * sin(8.0 * r - 2.0 * a);
					b = 0.3125 / r + cos(7.0 * a + b * b) / (100.0 * r);
					b *= smoothstep(0.0, 0.4, b);

					gl_FragColor = vec4(b * .3, .3 * b + 0.2 * sin(a), b * 0.5, 1.0);
				}
			"></gl-shader>
		</gl-program>
	</gl-framebuffer>
	<gl-vertexbuffer id="pos" size="2" data="[
		-1,-1, 
		 1,-1, 
		-1, 1,
		-1, 1, 
		 1,-1, 
		 1, 1
	]"></gl-vertexbuffer>
	<gl-vertexbuffer id="color" size="4" data="[
		1,1,1,1,
        0,1,0,1,
        1,0,1,1,
        1,0,1,1,
        0,1,0,1,
        0,0,0,1
	]"></gl-vertexbuffer> 
-->