<link rel="import" href="GLElement.html">
<link rel="import" href="GLResource.html">
<link rel="import" href="GLShader.html">

<script>(function STATIC(){
	"use strict";
	const GL 			= WebGLRenderingContext.prototype;
	const NS 			= Symbol.for("GLElements");
	const GLOBAL 		= window[NS];
	const PROTOTYPE 	= GLOBAL.Interface.GLElement;
	const GLShader 		= GLOBAL.Class.GLShader;
	const GLResource 	= GLOBAL.Class.GLResource;

	const METHODS = {
		
	};
	const ENUM = {
		$TYPE_VERTEX:GL.VERTEX_SHADER,
		$TYPE_FRAGMENT:GL.FRAGMENT_SHADER
	};
	const ATTRIBUTES = {
		type:GL.FRAGMENT_SHADER,
		code:""
	};
	const LIFECYCLE = {
		
		created:function(){
			if(this.parentElement.createShader){
				//console.log(this.type,this.code);
				this.shader = this.parentElement.createShader(
					this.id,
					this.type
				);
				this.compiler = this.shader.code
				.createPointer(processIncludes)
				.createPointer(processCode)
				.createPointer(this)
				;

				this.compiler.process(this.code);
				

				/*
				this.loader = this.compiler
				.createPointer(loadXHR)
*/
				//this.compiler.process(this.code);
			} else this.dispatch("shader-element-disconnected");

		}
	};
	const isInclude = /#include/;
	const testInclude = /#include (\S*) ([^\s;]*)([^;]*);/;
	function includeExternal(lineNo){

	}
	function processIncludes(element,lines) {

	}
	function processCode(element,code) {
		console.log(code);
		if(!code) code = "";
		var lines = code.split("\n");
		lines = lines.filter(function(line){
			return line;
		}).map(function(line,lineNo){
			if(isInclude.test(line)){
				var includes = testInclude.exec(line);	
				if(includes){
					var statement = includes[0];
					

					var type = includes[1];
					var path = includes[2];
					var args = eval("new Object({"+includes[3]+"})"); //lazy here
					if(type in GLResource) {
						return element.compiler.createPointer(
							GLResource[type](path,args));
					} else console.error("include type not static method of GLResource");
				} else console.error(
					element.tagName,
					element.id,
					lineNo,
					": invalid include format '#include type path [{option:value...}]'"
				);
			}
			else return line;
		},this);

		//console.log(lines);
		var shader = this.next(element,lines);
		
		if(shader.COMPILE_STATUS) element.dispatch("shader-compile-success",{
			shader:shader
		});
		else element.dispatch("shader-compile-error",{
			shader:shader,
			error:shader.infoLog
		});
		//return shader;
	}

	new GLOBAL.Element(PROTOTYPE,"gl-shader")
		.copy(METHODS,"methods")
		.copy(ATTRIBUTES,"attributes")
		.copy(LIFECYCLE,"lifecycle")
		.copy(ENUM,"enum")
	;
})();/* 

codeChanged:function(o,n){
			//this.shader.code.process(this.code);
			if(n && this.shader.gl) this.recompileShader();
		},
		typeChanged:function(o,n){
			//this.shader.type = this.type;
			if(n && this.shader.gl) this.recompileShader();	
		},
		sharedChanged:function(o,n){
			this.shader.shared = this.shared;
			this.dispatch("shader-scope-changed",{
				shader:this.shader,
				shared:this.shared
			});
		},
		srcChanged:function(o,n){
			const $ = this;
			
			if (n) {
				this.dispatch("shader-loading-started",{
					shader:this.shader
				});
				this.shader.loadAsync(n).then(function(shader){
					$.recompileShader();
				},function(error){
					$.dispatch("shader-loading-error",{
						shader:$.shader,
						error:error
					});
				});
			} else {
				if(this.shader.imported){
					//this.shader.imported = "";
					this.recompileShader();
				} else if (!this.shader.COMPILE_STATUS) {
					this.recompileShader();
				}
			}
		},
		includesChanged:function(o,n){
			if(n && this.shader.gl) {
				this.shader.includeQuery(n);
				this.recompileShader();
			}
		},
		checkintervalChanged:function(o,n){
			this.shader.dirtyCheck(this.checkinterval);
		},
		recompileShader:function(){
			this.shader.recompile()
			if(this.shader.COMPILE_STATUS){
				this.dispatch("shader-compile-success",{
					shader:this.shader
				});
			}else{
				console.error(this.shader.InfoLog);
				this.dispatch("shader-compile-error",{
					shader:this.shader,
					error:this.shader.InfoLog
				});
			}
		},
	PROTOTYPE.describeElement(PROTOTYPE,"gl-shader",
		{
			methods:METHODS,
			attributes:ATTRIBUTES,
			lifecycle:LIFECYCLE,
			enum:ENUM,
			factories:FACTORIES
		}
	);
*/</script>