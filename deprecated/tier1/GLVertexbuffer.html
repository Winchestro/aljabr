<link rel="import" href="GLVertexAttributePointer.html">

<script>(function STATIC(){
	"use strict";
	const GL 						= WebGLRenderingContext.prototype;
	const NS 						= Symbol.for("GLElements");
	const GLOBAL 					= window[NS];
	const GLResource 				= GLOBAL.Class.GLResource;
	const GLVertexAttributePointer 	= GLOBAL.Class.GLVertexAttributePointer;

	function  GLVertexbuffer( gl, program, target, pointer ){
		if(!(this instanceof GLVertexbuffer)) return new GLVertexbuffer(
			gl, program, target
		);
		
		this.gl = gl;
		this.program = program;

		if(target === GL.ARRAY_BUFFER){
			this.target = GL.ARRAY_BUFFER;
			this.pointer = this.createVertexAttribPointer(pointer);
		}
		else this.target = GL.ELEMENT_ARRAY_BUFFER;
		this.needsUpdate = true;
		this.buffer = new GLResource().setTarget(program.attributes).setSource(
			new GLResource(this,buffer)
		);
		this.create().bind();
		if(this.pointer) this.pointer.enable().update();
	}
	function buffer(vbo,data, offset){
		//var offset = vbo.SIZE;
		vbo.updateBinding();
		//console.log(arguments);
		if(vbo.needsUpdate){
			vbo.bufferData(data);
			vbo.needsUpdate = false;
		}
		else vbo.bufferSubData ( offset || 0, data.byteLength, data );

		
		return vbo;
	}
	const DATA = {
		usage:GL.STATIC_DRAW,
	};
	const FACTORIES = {
		createVertexAttribPointer:function(uuid){
			return new GLVertexAttributePointer(this.gl,uuid);
		}
	};
	const PROTOTYPE = {
		init:function(){

		},
		updateBinding:function(){
			if(this.target === GL.ELEMENT_ARRAY_BUFFER){
				if(this.ELEMENT_ARRAY_BUFFER_BINDING !== this.object) this.bind();
			} else if(this.ARRAY_BUFFER_BINDING !== this.object) this.bind();
			return this;
		},
	};
	const BINDINGS = {
		create:function(){
			this.object = this.gl.createBuffer();
			return this;
		},
		delete:function(){
			this.gl.deleteBuffer(this.object);
			return this;
		},
		bind:function(){
			this.gl.bindBuffer(this.target,this.object);
			return this;
		},
		unbind:function(){
			this.gl.bindBuffer(this.target,null);
			return this;
		},
		bufferData:function(data){
			gl.bufferData(
				this.target,
				data,
				this.usage
			);
			return this;
		},
		bufferSubData : function ( offset, size, data ) {
			this.gl.bufferSubData (
				this.target,
				offset,
				data
			);
			return this;
		},
	};
	const ACCESSORS = {
		USAGE:{
			get:function(){
				this.updateBinding();
				return this.gl.getBufferParameter(this.target,GL.BUFFER_USAGE);
			}
		},
		SIZE:{
			get:function(){
				this.updateBinding();
				return this.gl.getBufferParameter(this.target,GL.BUFFER_SIZE);
			}
		},
		MAX_VERTEX_ATTRIBS:{
			get:function(){
				return this.gl.getParameter(GL.MAX_VERTEX_ATTRIBS);
			}
		},
		ARRAY_BUFFER_BINDING:{
			get:function(){
				return this.gl.getParameter(GL.ARRAY_BUFFER_BINDING);
			}
		},
		ELEMENT_ARRAY_BUFFER_BINDING:{
			get:function(){
				return this.gl.getParameter(GL.ELEMENT_ARRAY_BUFFER_BINDING);
			}
		}
	};

	new GLOBAL.Class(PROTOTYPE,GLVertexbuffer)
		.copy(DATA)
		.copy(FACTORIES)
		.copy(BINDINGS)
		.define(ACCESSORS)
	;

	
})();
/*
*/</script>
