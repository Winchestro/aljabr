<link rel="import" href="GLResource.html">
<script>(function STATIC(){
	"use strict";
	const GL 			= WebGLRenderingContext.prototype;
	const NS 			= Symbol.for("GLElements");
	const GLOBAL 		= window[NS];
	const GLResource 	= GLOBAL.Class.GLResource;

	function GLShader(gl,program,type){
		if(!(this instanceof GLShader)) return new GLShader( gl,program,type );
		this.gl = gl;
		this.code = new GLResource().setTarget(program.shaders).setSource(
			new GLResource(this,compileShader).createSource(concatStrings)
		);
		this.object = this.gl.createShader(type);
	}
	function concatStrings(){
		return [].slice.call(arguments).join("\n");
	}
	function compileShader(shader,code){
		shader.source = code;
		if(!shader.compile()) console.info(shader.infoLog);
		return shader;
	}
	const DATA = {
		type : GL.FRAGMENT_SHADER,
	};
	const PROTOTYPE = {
		
		/*
		includeQuery:function(query,property){
			if(!query) return this;
			property = property || "innerText";
			this.included = [].slice.call(document.querySelectorAll(query))
			.reduce(function(p,c){
				return p+c[property];
			},"");

			return this;
		},
		loadAsync:function(url){
			this.src = url;
			if(!url){
				this.imported = "";
				return Promise.resolve(this);
			}
			const x = new XMLHttpRequest;
			const $ = this;
			
			const p =  new Promise(function(resolve,reject){	
				x.onreadystatechange = function(){
					if(x.readyState === x.DONE){
						if(x.status === 200){
							$.imported = x.response;
							resolve($);
						}else{
							reject(x.status);
						}
					}
				}	
			});
			x.open("GET",url);
			x.send();
			return p;
		},
		dirtyCheck:function(interval){
			const $ = this;
			if(this.checkInterval){
				clearInterval(this.checkInterval);
				this.checkInterval = 0;
			}
			if(interval) this.checkInterval = setInterval(function(){
				$.loadAsync($.src);
			},interval);
		}
		*/
	};
	const BINDINGS = {
		delete:function(){
			this.gl.deleteShader(this.object);
			return this.DELETE_STATUS;
		},
		compile:function(){
			this.gl.compileShader(this.object);
			return this.COMPILE_STATUS;
		},
	};
	const ACCESSORS = {
		SHADER_TYPE:{
			get:function(){
				return this.gl.getShaderParameter(this.object,GL.SHADER_TYPE);
			}
		},
		DELETE_STATUS:{
			get:function(){
				return this.gl.getShaderParameter(this.object,GL.DELETE_STATUS);
			}
		},
		COMPILE_STATUS:{
			get:function(){
				return this.gl.getShaderParameter(this.object,GL.COMPILE_STATUS);
			}
		},
		source:{
			set:function(code){
				this.gl.shaderSource(this.object,code);
			},
			get:function(){
				return this.gl.getShaderSource(this.object);
			}
		},
		infoLog:{
			get:function(){
				return this.gl.getShaderInfoLog(this.object);
			}
		}
	};

	new GLOBAL.Class(PROTOTYPE,GLShader)
		.copy(DATA)
		.copy(BINDINGS)
		.define(ACCESSORS)
	;
})();/* 


	PROTOTYPE.describeElement(PROTOTYPE,"gl-shader",
		{
			methods:METHODS,
			attributes:ATTRIBUTES,
			lifecycle:LIFECYCLE,
			enum:ENUM,
			factories:FACTORIES
		}
	);
*/</script>