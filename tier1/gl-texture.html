<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="gl-element.html">

<polymer-element name="gl-texture" constructor="glTexture" extends="gl-element">
<template>
	<style>
		host:{
			display:none;
		}
	</style>
</template>
<script>Polymer((function STATIC(){
	"use strict;"
	const GL = WebGLRenderingContext.prototype;
	const BINDINGS = {
		activeTexture:{
			value:function(textureUnit){
				this.textureUnit = textureUnit || this.textureUnit;
				this.gl.activeTexture(GL.TEXTURE0 + this.textureUnit);
				return this;
			}
		},
		createTexture:{
			value:function(){
				this.texture = this.gl.createTexture();
				return this;
		  }
		},
		deleteTexture:{
			value:function(){
				this.gl.deleteTexture(this.texture);
				return this;
			}
		},
		bindTexture:{
			value:function(target){
				this.target = target || this.target;
				this.gl.bindTexture(this.target,this.texture);
				return this;
			}
		},
		unbindTexture:{
			value:function(target){
				this.target = target || this.target;
				this.gl.bindTexture(this.target,null);
				return this;
			}
		},
		generateMipmap:{
			value:function(){
				this.gl.generateMipmap(this.target);
				return this;
			}
		},
		copyTexImage2D:{
			value:function(x,y,width,height,level,format){
				this.x = x||this.x;
				this.y = y||this.y;
				this.width = width || this.width;
				this.height = height || this.height;
				this.level = level || this.level;
				this.format = format || this.format;
				this.gl.copyTexImage2D(this.target,this.level,this.format,this.x,this.y,this.width,this.height,0);
				return this;
			}
		},
		copyTexSubImage2D:{
			value:function(xoffset,yoffset,x,y,width,height,level,format){
				this.x = x||this.x;
				this.y = y||this.y;
				this.width = width || this.width;
				this.height = height || this.height;
				this.xoffset = xoffset || this.xoffset;
				this.yoffset = yoffset || this.yoffset;
				this.level = level || this.level;
				this.format = format || this.format;
				this.gl.copyTexImage2D(this.target,this.level,this.xoffset,this.yoffset,this.format,this.x,this.y,this.width,this.height);
				return this;
			}
		},
		pixelStorei:{
			value:function(pname,param){
				this.pname = pname || this.pname;
				this.param = param || this.param;
				this.gl.pixelStorei(this.pname,this.param);
				return this;
			}
		},
		texParameteri:{
			value:function(MIN,MAG,S,T){
				this.MIN = MIN || this.MIN;
				this.MAG = MAG || this.MAG;
				this.S = S || this.S;
				this.T = T || this.T;

				this.gl.texParameteri(this.target,GL.TEXTURE_MIN_FILTER,this.MIN);
				this.gl.texParameteri(this.target,GL.TEXTURE_MAG_FILTER,this.MAG);
				this.gl.texParameteri(this.target,GL.TEXTURE_WRAP_S,this.S);
				this.gl.texParameteri(this.target,GL.TEXTURE_WRAP_T,this.T);
				return this;
			}
		},
		texImage2D:{
			value:function(data,level,format,type,width,height){
				this.data = data || this.data;
				this.level = level || this.level;
				this.format = format || this.format;
				this.type = type || this.type;
				this.width = width || this.width;
				this.height = height || this.height;

				if(
					this.data instanceof ImageData||
					this.data instanceof HTMLCanvasElement||
					this.data instanceof HTMLVideoElement||
					this.data instanceof HTMLImageElement
				){
					this.gl.texImage2D(
						this.target,
						this.level,
						this.format,
						this.format,
						this.type,
						this.data
					);
				}else{
					if(this.data instanceof Array){
						this.data = new window[this.arrayType](this.data);
					}
					this.gl.texImage2D(
						this.target,
						this.level,
						this.format,
						this.width,
						this.height,
						0,//so wanky
						this.format,//again :O
						this.type,
						this.data
				  );
				}
				return this;
			}
		},
		texSubImage2D:{
			value:function(xoffset,yoffset,data,level,format,type,width,height){
				this.data = data || this.data;
				this.level = level || this.level;
				this.xoffset = xoffset || this.xoffset;
				this.yoffset = yoffset || this.yoffset;
				this.format = format || this.format;
				this.type = type || this.type;
				this.width = width || this.width;
				this.height = height || this.height;

				if(
				  this.data instanceof ImageData||
				  this.data instanceof HTMLCanvasElement||
				  this.data instanceof HTMLVideoElement||
				  this.data instanceof HTMLImageElement
				){
					this.gl.texSubImage2D(
						this.target,
						this.level,
						this.xoffset,
						this.yoffset,
						this.format,
						this.format,
						this.type,
						this.data
					);
				}else{
					if(this.data instanceof Array){
						this.data = new window[this.arrayType](this.data);
					}
					this.gl.texSubImage2D(
						this.target,
						this.level,
						this.xoffset,
						this.yoffset,
						this.format,
						this.width,
						this.height,
						0,//so wanky
						this.format,//again :O
						this.type,
						this.data
					);
				}
				return this;
			}
		},
	};
	const STATES={
		$MAG_FILTER:{
			get:function(){
				return this.gl.getTexParameter(this.target,GL.TEXTURE_MAG_FILTER);
			}
		},
		$MIN_FILTER:{
			get:function(){
				return this.gl.getTexParameter(this.target,GL.TEXTURE_MIN_FILTER);
			}
		},
		$WRAP_S:{
			get:function(){
				return this.gl.getTexParameter(this.target,GL.TEXTURE_WRAP_S);
			}
		},
		$WRAP_T:{
		  get:function(){
				return this.gl.getTexParameter(this.target,GL.TEXTURE_WRAP_T);
			}
		}
	};
	const ACCESSORS={
		$CHILD:{
			get:function(){
				return Array.prototype.slice.call(this.children).filter(function(e){
					return e instanceof HTMLImageElement||e instanceof HTMLVideoElement||e instanceof HTMLCanvasElement;
				})[0]
			}
		}
	};
	const METHODS={
		setupTexture:{
			value:function(gl){
				if(!(gl instanceof WebGLRenderingContext))
				return new TypeError("First Argument not WebGLRenderingContext")
				const TEXTURE = this;
				const IMG = this.$CHILD;
				TEXTURE.gl = gl;

				if(TEXTURE.src)return TEXTURE.load(TEXTURE.src);
				else if (IMG)return new Promise(function(res,err){
					if(IMG.complete){
						res(TEXTURE.processData(IMG));
					}else{
						IMG.addEventListener("load",function(){
							res(TEXTURE.processData(IMG));
						});
					}
				})
				else if (TEXTURE.data)  return TEXTURE.processData();
			}
		},
		load:{
			value:function(path){
				const TEXTURE = this;
				return new Promise(function(res,err){
					const IMG = new Image;
					IMG.onload = function(){
						TEXTURE.width = IMG.width;
						TEXTURE.height = IMG.height;
						res(TEXTURE.processData(IMG));
					};
					IMG.src = path;
				});
			}
		},
		processData:{
		  value:function(data){
				this.data = data || this.data;
				if(typeof this.data === "string"){
					this.data = this.attrToHexArray(this.data);
					this.width = this.height = Math.sqrt(this.data.length/4);
				}
				return this
				.createTexture()
				.activeTexture()
				.bindTexture()
				.pixelStorei(GL.UNPACK_FLIP_Y_WEBGL,true)
				.texImage2D(this.data)
				.texParameteri()
			}
		},
	}; 
	const PROTOTYPE={
		publish:{
			src:"",
			data:null,
			x:0,
			y:0,
			xoffset:0,
			yoffset:0,
			width:0,
			height:0,
			level:0,
			arrayType:"Uint8Array",
			format:GL.RGBA,
			target:GL.TEXTURE_2D,
			type:GL.UNSIGNED_BYTE,
			MIN:GL.NEAREST,
			MAG:GL.NEAREST,
			S:GL.CLAMP_TO_EDGE,
			T:GL.CLAMP_TO_EDGE
		}
	};
	Object.defineProperties(PROTOTYPE,BINDINGS);
	Object.defineProperties(PROTOTYPE,STATES);
	Object.defineProperties(PROTOTYPE,ACCESSORS);
	Object.defineProperties(PROTOTYPE,METHODS);
	return PROTOTYPE;
})());
/*
*/</script>
</polymer-element>
