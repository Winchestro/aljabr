<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="gl-element.html">

<polymer-element name="gl-vertexbuffer" constructor="glVertexBuffer" extends="gl-element">
<script>Polymer((function STATIC(){
	"use strict";
	const GL = WebGLRenderingContext.prototype;
	const BINDINGS={
		createBuffer:{
			value:function(){
				this.buffer =this.gl.createBuffer();
				return this;
			}
		},
		deleteBuffer:{
			value:function(){
			 this.gl.deleteBuffer(this.buffer);
				return this;
			}
		},
		bindBuffer:{
			value:function(){
			 this.gl.bindBuffer(this.target,this.buffer);
				return this;
			}
		},
		unbindBuffer:{
			value:function(){
			 this.gl.bindBuffer(this.target,null);
				return this;
			}
		},
		bufferData:{
			value:function(data,usage){
				this.data = data || this.data;
				this.usage = usage || this.usage;
				this.gl.bufferData(
					this.target,
					this.data,
					this.usage
				);
				return this;
			}
		},
		bufferSubData:{
			value:function(data,offset){
				this.data   = data    || this.data;
				this.offset = offset  || this.offset;
				console.trace(arguments.callee)
			 this.gl.bufferSubData(
					this.target,
					this.offset,
					this.data
				);
				return this;
			}
		},
		getVertexAttrib:{
			/*
				VERTEX_ATTRIB_ARRAY_BUFFER_BINDING  WebGLBuffer
				VERTEX_ATTRIB_ARRAY_ENABLED         GLboolean
				VERTEX_ATTRIB_ARRAY_SIZE            GLint
				VERTEX_ATTRIB_ARRAY_STRIDE          GLint
				VERTEX_ATTRIB_ARRAY_TYPE            GLenum
				VERTEX_ATTRIB_ARRAY_NORMALIZED      GLboolean
				CURRENT_VERTEX_ATTRIB               Float32Array (with 4 elements)
			*/
			value:function(_index_,_pname_){
				return this.gl.getVertexAttrib(
					_index_,
					_pname_
				);
			}
		},
		getVertexAttribOffset:{
			value:function(_index_,_pname_){
				return this.gl.getVertexAttribOffset(
					_index_,
					_pname_
				);
			}
		},
		vertexAttribPointer:{
			value:function(_index_,size,type,normalized,stride,offset){
				this.size       = size        || this.size;
				this.type       = type        || this.type;
				this.normalized = normalized  || this.normalized;
				this.stride     = stride      || this.stride;
				this.offset     = offset      || this.offset;
				this.gl.vertexAttribPointer(
					_index_,
					this.size,
					this.type,
					this.normalized,
					this.stride,
					this.offset
				);
				return this;
			}
		},
		enableVertexAttribArray:{
			value:function(_location_){
				this.gl.enableVertexAttribArray(_location_);
				return this;
			}
		},
	};
	const STATES={
		$USAGE:{
			get:function(){
				return this.gl.getBufferParameter(this.target,GL.BUFFER_USAGE);
			}
		},
		$SIZE:{
			get:function(){
				return this.gl.getBufferParameter(this.target,GL.BUFFER_SIZE);
			}
		}
	};
	const ACCESSORS={
		target:{
			get:function(){
				return this.element?
				GL.ELEMENT_ARRAY_BUFFER:
				GL.ARRAY_BUFFER;
			},
			set:function(n){
				n===GL.ELEMENT_ARRAY_BUFFER?this.element=true:
				n===GL.ARRAY_BUFFER?this.element=false:
				console.error("invalid target");
			}
		},
		usage:{
			get:function(){
				return this.dynamic?
				GL.DYNAMIC_DRAW:
				GL.STATIC_DRAW;
			},
			set:function(n){
				n===GL.DYNAMIC_DRAW?this.dynamic=true:
				n===GL.STATIC_DRAW?this.dynamic=false:
				console.error("invalid usage");
			}
		},
	};
	const METHODS={
		setupBuffer:{
			value:function(gl,index){
				const BUFFER = this;
				if(!(gl instanceof WebGLRenderingContext))
					return new TypeError("First Argument not WebGLRenderingContext")
				BUFFER.gl = gl;
				BUFFER.index = index;
				if(this.LOADED)			return BUFFER.processData();
				else					return new Promise(function(res,err){
					BUFFER.addEventListener("load",function handler(){
						BUFFER.removeEventListener("load",handler);
						BUFFER.LOADED = true;
						res(BUFFER.processData());
					})
				});
			}
		},
		pointAt:{
			value:function(index){
				index = index || this.index;
				return this.enableVertexAttribArray(index).vertexAttribPointer(index);
			}
		},
		processData:{
			value:function(){
				return this.createBuffer().bindBuffer().bufferData().pointAt();
			}
		},
		convertToTypedArray:{
			value:function(){
				if(this.data&&window[this.arrayType]&&!(this.data instanceof window[this.arrayType])){
					if(typeof this.data === "string"){
						this.data = JSON.parse(this.data);
					}
					this.data = new window[this.arrayType](this.data);
					
				}
				return this;
			}
		},
	};
	const PROTOTYPE={
		publish:{
			size:4,
			element:false,
			dynamic:false,
			data:null,
			arrayType:"Float32Array",
			offset:0,
			type:GL.FLOAT,
			normalized:false,
			stride:0
		},
		ready:function(){
			if(this.data){
				this.convertToTypedArray();
				this.LOADED = true;
				this.fire("load");
			}
		},
		dataChanged:function(o,n){
			if(!this.gl)return;

			this.convertToTypedArray().processData();
		},
	};
	Object.defineProperties(PROTOTYPE,BINDINGS);
	Object.defineProperties(PROTOTYPE,STATES);
	Object.defineProperties(PROTOTYPE,ACCESSORS);
	Object.defineProperties(PROTOTYPE,METHODS);
	return PROTOTYPE;
})());
/*
	(function(target,alias){
		var args; 
		function traveler(){
			args=Array.prototype.slice.call(arguments);
			return target.µ;
		};
		Object.keys(alias).forEach(function(method){
			Object.defineProperty(traveler,method,{
				get:function(){
					return target[alias[method]].apply(target,args).µ;
				}
			});
		});
		Object.defineProperty(target,"µ",{
			get:function(){return traveler;}
		});
	})(this,{
		c:"create",
		e:"delete",
		b:"bind",
		u:"unbind",
		d:"bufferData",
		s:"bufferSubData"
	});
*/</script>
</polymer-element>
