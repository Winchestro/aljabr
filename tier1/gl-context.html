<link rel="import" href="gl-program.html">
<link rel="import" href="gl-rendertarget.html">

<polymer-element name="gl-context" extends="gl-rendertarget">
<template>
	<style>
		:host{
			display: block;
			position:absolute;
			top:0;
			bottom:0;
			left:0;
			right:0;
		}
		canvas{
			all:inherit;
			visibility: visible;
			background:grey;
			width:100%;
			height:100%;
		}
	</style>
	<canvas id="canvas" width="{{width / quality}}" height="{{height / quality}}"></canvas>
</template>
<script>Polymer(function STATIC(){
	"use strict";
	const GL = WebGLRenderingContext.prototype;
	
	const BINDINGS = [
		"lineWidth",
		"pixelStorei",
		"polygonOffset",
		"sampleCoverage",
		"enable",
		"disable",
		"depthFunc",
		"depthMask",
		"depthRange",
		"stencilFunc",
		"stencilFuncSeparate",
		"stencilMask",
		"stencilMaskSeparate",
		"stencilOp",
		"stencilOpSeparate",
		"blendFunc",
		"blendFuncSeparate",
		"blendEquation",
		"blendEquationSeparate",
		"blendColor",
		"scissor",
		"frontFace",
		"colorMask",
		"cullFace",
		"hint",
		"getExtension"
	];
	const STATES = [
		"ACTIVE_TEXTURE",
		"ALIASED_LINE_WIDTH_RANGE",
		"ALIASED_POINT_SIZE_RANGE",
		"ALPHA_BITS",
		"ARRAY_BUFFER_BINDING",
		"BLEND",
		"BLEND_COLOR",
		"BLEND_DST_ALPHA",
		"BLEND_DST_RGB",
		"BLEND_EQUATION_ALPHA",
		"BLEND_EQUATION_RGB",
		"BLEND_SRC_ALPHA",
		"BLEND_SRC_RGB",
		"BLUE_BITS",
		"COLOR_CLEAR_VALUE",
		"COLOR_WRITEMASK",
		"COMPRESSED_TEXTURE_FORMATS",
		"CULL_FACE",
		"CULL_FACE_MODE",
		"CURRENT_PROGRAM",
		"DEPTH_BITS",
		"DEPTH_CLEAR_VALUE",
		"DEPTH_FUNC",
		"DEPTH_RANGE",
		"DEPTH_TEST",
		"DEPTH_WRITEMASK",
		"DITHER",
		"ELEMENT_ARRAY_BUFFER_BINDING",
		"FRAMEBUFFER_BINDING",
		"FRONT_FACE",
		"GENERATE_MIPMAP_HINT",
		"GREEN_BITS",
		"IMPLEMENTATION_COLOR_READ_FORMAT",
		"IMPLEMENTATION_COLOR_READ_TYPE",
		"LINE_WIDTH",
		"MAX_COMBINED_TEXTURE_IMAGE_UNITS",
		"MAX_CUBE_MAP_TEXTURE_SIZE",
		"MAX_FRAGMENT_UNIFORM_VECTORS",
		"MAX_RENDERBUFFER_SIZE",
		"MAX_TEXTURE_IMAGE_UNITS",
		"MAX_TEXTURE_SIZE",
		"MAX_VARYING_VECTORS",
		"MAX_VERTEX_ATTRIBS",
		"MAX_VERTEX_TEXTURE_IMAGE_UNITS",
		"MAX_VERTEX_UNIFORM_VECTORS",
		"MAX_VIEWPORT_DIMS",
		"PACK_ALIGNMENT",
		"POLYGON_OFFSET_FACTOR",
		"POLYGON_OFFSET_FILL",
		"POLYGON_OFFSET_UNITS",
		"RED_BITS",
		"RENDERBUFFER_BINDING",
		"RENDERER",
		"SAMPLE_BUFFERS",
		"SAMPLE_COVERAGE_INVERT",
		"SAMPLE_COVERAGE_VALUE",
		"SAMPLES",
		"SCISSOR_BOX",
		"SCISSOR_TEST",
		"SHADING_LANGUAGE_VERSION",
		"STENCIL_BACK_FAIL",
		"STENCIL_BACK_FUNC",
		"STENCIL_BACK_PASS_DEPTH_FAIL",
		"STENCIL_BACK_PASS_DEPTH_PASS",
		"STENCIL_BACK_REF",
		"STENCIL_BACK_VALUE_MASK",
		"STENCIL_BACK_WRITEMASK",
		"STENCIL_BITS",
		"STENCIL_CLEAR_VALUE",
		"STENCIL_FAIL",
		"STENCIL_FUNC",
		"STENCIL_PASS_DEPTH_FAIL",
		"STENCIL_PASS_DEPTH_PASS",
		"STENCIL_REF",
		"STENCIL_TEST",
		"STENCIL_VALUE_MASK",
		"STENCIL_WRITEMASK",
		"SUBPIXEL_BITS",
		"TEXTURE_BINDING_2D",
		"TEXTURE_BINDING_CUBE_MAP",
		"UNPACK_ALIGNMENT",
		"UNPACK_COLORSPACE_CONVERSION_WEBGL",
		"UNPACK_FLIP_Y_WEBGL",
		"UNPACK_PREMULTIPLY_ALPHA_WEBGL",
		"VENDOR",
		"VERSION",
		"VIEWPORT"
	];
	
	const ACCESSORS = {
		$canvasContext:{
			get:function(){
				var options = {
					alpha:typeof this.alpha === "string",
					depth:typeof this.depth === "string",
					stencil:typeof this.stencil === "string",
					antialias:this.antialias,
					premultipliedAlpha:this.premultipliedAlpha,
					preserveDrawingBuffer:this.preserveDrawingBuffer
				};
				return this.$.canvas.getContext("webgl",options)||
				this.$.canvas.getContext("experimental-webgl",options);
			}
		},
		$CSSContext:{
			get:function(){
				var options = {
					alpha:this.alpha,
					depth:this.depth,
					stencil:this.stencil,
					antialias:this.antialias,
					premultipliedAlpha:this.premultipliedAlpha,
					preserveDrawingBuffer:this.preserveDrawingBuffer
				};
				return document.getCSSCanvasContext(
					'webgl',
					this.cssid,
					this.w/this.quality,
					this.h/this.quality,
					options
				)||document.getCSSCanvasContext(
					'experimental-webgl',
					this.cssid,
					this.w/this.quality,
					this.h/this.quality,
					options
				);
			}
		},
		$supportedExtensions:{
			get:function(){
				return this.gl.getSupportedExtensions();
			}
		},
	};
	const FACTORIES = {
		createProgram:{
			value:function(){
				var p = new glProgram();
				p.gl = this.gl;
				return p;
			}
		},
	};
	const METHODS = {
		updateContext:{
			value:function(){
				this.gl=this.$canvasContext;
				return this.gl;
			}
		},
	};
	const OBSERVERS = {
		dimensionsUpdated:{
			value:function(o,n){
				this.gl = this.updateContext();
			}
		},
		depthChanged:{
			value:function(o,n){
				if(!this.gl)return;
				
				const ARGS = this.attrToArgs(n);

				if(typeof this.depth ==="string")this.enable(GL.DEPTH_TEST).depthFunc(
					this.lookupFlag(ARGS[0]||"LEQUAL")
				).depthRange(
					Number(ARGS[1])||0,
					Number(ARGS[2])||1
				);
				else this.disable(GL.DEPTH_TEST);
				if(this.render)this.render();
				return this;
			}
		},
		alphaChanged:{
			value:function(o,n){
				if(!this.gl)return;
				//console.log(n);
				const ARGS = this.attrToArgs(n);
				if(typeof this.alpha === "string")this.enable(GL.BLEND).blendFunc(
					/*	
						ZERO
						ONE
						SRC_COLOR
						ONE_MINUS_SRC_COLOR
						DST_COLOR
						ONE_MINUS_DST_COLOR
						SRC_ALPHA
						ONE_MINUS_SRC_ALPHA
						DST_ALPHA
						ONE_MINUS_DST_ALPHA
						CONSTANT_COLOR
						ONE_MINUS_CONSTANT_COLOR
						CONSTANT_ALPHA
						ONE_MINUS_CONSTANT_ALPHA
						SRC_ALPHA_SATURATE
					*/
					this.lookupFlag(ARGS[0]||"SRC_ALPHA"),
					/*
						ZERO
						ONE
						SRC_COLOR
						ONE_MINUS_SRC_COLOR
						DST_COLOR
						ONE_MINUS_DST_COLOR
						SRC_ALPHA
						ONE_MINUS_SRC_ALPHA
						DST_ALPHA
						ONE_MINUS_DST_ALPHA
						CONSTANT_COLOR
						ONE_MINUS_CONSTANT_COLOR
						CONSTANT_ALPHA
						ONE_MINUS_CONSTANT_ALPHA
					*/
					this.lookupFlag(ARGS[1]||"ONE_MINUS_SRC_ALPHA")
				).blendEquation(
					/*
						FUNC_ADD
						FUNC_SUBTRACT
						FUNC_REVERSE_SUBTRACT
					*/
					this.lookupFlag(ARGS[2]||"FUNC_ADD") 
				).blendColor(
					Number(ARGS[3])||0,
					Number(ARGS[4])||0,
					Number(ARGS[5])||0,
					Number(ARGS[6])||0
				);
				else this.disable(GL.BLEND);
				if(this.render)this.render();
				return this;
			}
		},
		cullfaceChanged:{
			value:function(o,n){
				if(!this.gl)return;

				const ARGS = this.attrToArgs(n);

				if(typeof this.cullface === "string")this.enable(GL.CULL_FACE).cullFace(
					/*
						FRONT
						BACK
						FRONT_AND_BACK
					*/
					this.lookupFlag(ARGS[0]||"BACK")
				).frontFace(
					/* https://www.khronos.org/opengles/sdk/docs/man/xhtml/glFrontFace.xml
						CW
						CCW
					*/
					this.lookupFlag(ARGS[1]||"CCW")
				);
				else this.disable(GL.CULL_FACE);
				if(this.render)this.render();
				return this;
			}
		},
		polygonoffsetChanged:{
			value:function(o,n){
				if(!this.gl)return;

				const ARGS = this.attrToArgs(n);

				if(typeof this.polygonoffset === "string")this
				.enable(GL.POLYGON_OFFSET_FILL)
				.polygonOffset(
					Number(ARGS[0])||0,
					Number(ARGS[1])||0
				);
				else this.disable(GL.POLYGON_OFFSET_FILL);
				if(this.render)this.render();
				return this;
			}
		},
		scissorChanged:{
			value:function(o,n){
				if(!this.gl)return;

				const ARGS = this.attrToArgs(n);

				if(typeof this.scissor === "string")this
				.enable(GL.SCISSOR_TEST)
				.scissor(
					Number(ARGS[0]||0),
					Number(ARGS[1]||0),
					Number(ARGS[2]||this.$width),
					Number(ARGS[3]||this.$height)
				);
				else this.disable(GL.SCISSOR_TEST);
				if(this.render)this.render();
				return this;
			}
		},
		stencilChanged:{
			value:function(o,n){
				/*
					TODO
				*/
				if(!this.gl)return;

				const ARGS = this.attrToArgs(n);

				if(typeof this.stencil === "string")this
				.enable(GL.STENCIL_TEST)
				.stencilFunc(
					/*
						NEVER
						LESS
						LEQUAL
						GREATER
						GEQUAL
						EQUAL
						NOTEQUAL
						ALWAYS
					*/
					lookupFlag(ARGS[0])||GL.ALWAYS,
					Number(ARGS[1])||0
				);
				else this.disable(GL.STENCIL_TEST);
				if(this.render)this.render();
				return this;
			}
		},
		samplecoverageChanged:{
			value:function(o,n){
				if(!this.gl)return;

				const ARGS = this.attrToArgs(n);

				if(typeof this.samplecoverage === "string")this
				.enable(GL.SAMPLE_COVERAGE)
				.sampleCoverage(
					Number(ARGS[0]||1),
					lookupFlag(ARGS[1])||GL.FALSE
				);
				else this.disable(GL.SAMPLE_COVERAGE);
				if(this.render)this.render();
				return this;
			}
		},
	};
	const PROTOTYPE = {
		publish:{
			width:document.documentElement.clientWidth,
			height:document.documentElement.clientHeight,
			quality:1,
			
			alpha:null,
			depth:null,
			stencil:null,

			cullface:null,
			polygonoffset:null,
			samplecoverage:null,
			
			dither:false,			
			antialias:false,
			premultipliedAlpha:false,
			preserveDrawingBuffer:false,

			loop:false,
			gui:false,
		},
		observe:{
			quality:"dimensionsUpdated",
			width:"dimensionsUpdated",
			height:"dimensionsUpdated"
		},
		
		redraw:function(){
			const $ = this;
			if($.render)loop();
			else console.warn("not ready to render");
			function loop(){
				//console.count("frames");
				if($.loop)requestAnimationFrame(loop);
				$.frames++;
				$.time = Date.now() - $.startTime;
				$.render();
			}	
		},
		created:function(){
			this.mouse = [0,0];
			this.startTime = Date.now();
			this.frames = 0;
		},
		ready:function(){
			this.updateContext();
			
			
			["depth","alpha","cullface"].forEach(function(e){
				this[e+"Changed"](null,this[e]);
			},this);
		},
		domReady:function(){
			const CTX = this;
			this.setupRendertarget(0,0,this.$width/this.quality,this.$height/this.quality)
			.then(function(render){
				CTX.render = render;
				CTX.redraw();
			})
		},
		attached:function(){
			this.addEventListener("mousemove",mouseHandler);
		},
		detached:function(){
			this.removeEventListener("mousemove",mouseHandler);
		},
	};
	//Object.defineProperties(PROTOTYPE,BINDINGS);
	for (var b in BINDINGS) PROTOTYPE[BINDINGS[b]] = new Function(
		"this.gl."+BINDINGS[b]+".apply(this.gl,[].slice.call(arguments));\nreturn this;"
	);
	for (var s in STATES) Object.defineProperty(PROTOTYPE,"$"+STATES[s],{
		get: new Function(
			"return this.gl.getParameter("+GL[STATES[s]]+")"
		)
	});
	//Object.defineProperties(PROTOTYPE,STATES);
	Object.defineProperties(PROTOTYPE,ACCESSORS);
	Object.defineProperties(PROTOTYPE,FACTORIES);
	Object.defineProperties(PROTOTYPE,OBSERVERS);
	Object.defineProperties(PROTOTYPE,METHODS);
	
	return PROTOTYPE;
	function mouseHandler(e){
		this.mouse[0] = e.clientX/this.$width;
		this.mouse[1] = 1.-e.clientY/this.$height;
		
		if(this.render && !this.loop){
			this.render();
		}
	}
}());
/* 
	
*/</script>
</polymer-element>
